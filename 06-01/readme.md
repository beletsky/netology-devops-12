# Домашнее задание к занятию "6.1. Типы и структура СУБД"

## Задача 1

> Архитектор ПО решил проконсультироваться у вас, какой тип БД 
> лучше выбрать для хранения определенных данных.
> 
> Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:
> 
> - Электронные чеки в json виде
> - Склады и автомобильные дороги для логистической компании
> - Генеалогические деревья
> - Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
> - Отношения клиент-покупка для интернет-магазина
> 
> Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

- Электронные чеки в json виде
  
  Для хранения данных в json-формате лучше всего подходят документо-ориентированные базы данных, например, популярная сейчас Mongo.
 
  Вместе с тем, чеки как объект хранения довольно хорошо формализуются в единый формат данных (а мелкие отличия между ними можно хранить и обрабатывать полями типа JSON в свободном формате), что позволит использовать для их хранения реляционную БД с поддержкой JSON-полей (практически все современные БД это поддерживают). Использование же реляционной БД вместо документо-ориентированной позволит легко и эффективно выполнять разного рода аналитические запросы к информации, тогда как в случае документо-ориентированных БД эффективность будет существенно ниже.

  Также, если основной задачей хранения чеков являются именно аналитические исследования, можно предложить использовать колоночные БД.
  

- Склады и автомобильные дороги для логистической компании
  
  Идеальным выбором будет графовая база данных, поскольку склады в исходной постановке хорошо представляются узлами, а дороги - ребрами между ними, и у каждого типа объектов существует свой набор характеристик.
  

- Генеалогические деревья
  
  Сама формулировка задачи по хранению деревьев подсказывает изначально, что правильным выбором будет иерархический тип базы данных. Однако, в реальных генеалогических деревьях легко могут возникать случаи, когда один и тот же предок будет фигурировать сразу в нескольких ветвях дерева. Кроме того, генеалогические деревья можно использовать также для хранения многих других типов отношений, кроме собственно "предок-потомок", например, для перехода прав владения, и в этом случае "дерево" в качестве структуры данных может перестать работать. Поэтому более правильно остановить свой выбор на графовой базе данных.  
  

- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
  
  Идентификаторы клиентов для аутентификации (чаще всего, это так называемые сессии) правильнее всего хранить в базах данных "ключ-значение", потому что фактически необходимо хранить только ключ (значение в данном случае вторично, но может быть использовано в ряде сценариев), плюс данные хранилища как правило имеют готовую поддержку времени жизни (TTL) записей, что идеально ложится на сценарий использования с ограниченным временем жизни. Традиционно для этого используют Redis.
  

- Отношения клиент-покупка для интернет-магазина
  
  Данные об отношениях различных объектов данных лучше всего обрабатываются в реляционных структурах данных (даже из названия: relation - отношение). Поэтому для решения этой задачи используем классическую СУБД линии MySQL, PostgreSQL, или проприетарные Oracle, MSSQL, IBM DB2 в зависимости от специфики задачи.
  

## Задача 2

> Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
> CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
> (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):
> 
> - Данные записываются на все узлы с задержкой до часа (асинхронная запись)
> - При сетевых сбоях, система может разделиться на 2 раздельных кластера
> - Система может не прислать корректный ответ или сбросить соединение
> 
> А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

- Данные записываются на все узлы с задержкой до часа (асинхронная запись)
  
  Такая система отдаёт предпочтение целостности перед доступностью, то есть принадлежит к классу CP.
  
  Классификация PACELC: PC/EL или PC/EC, поскольку нам по условию неизвестно поведение системы при работе на единственном узле. Можно предположить, что класс будет PC/EC, поскольку как правило системы, ориентированные на целостность, поддерживают это поведение для обоих вариантов развёртывания.


- При сетевых сбоях, система может разделиться на 2 раздельных кластера
  
  Данная система жертвует консистентностью данных ради доступности, поэтому она принадлежит к классу AP.

  По PACELC: PA/EL или PA/EC опять же по причине отсутствия информации о поведении системы при работе на единственном узле. Если разработчики ориентируются прежде всего на доступность системы, то класс будет PA/EL.
  

- Система может не прислать корректный ответ или сбросить соединение
  
  Данная система приносит в жертву доступность, поэтому её классы будут: CP и PC/EC.


## Задача 3

> Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

Данные принципы являются диаметрально противоположными:

- basic-availability (записать данные как можно скорее даже ценой потери данных или целостности между узлами) противоречит принципам atomicity (должны быть выполнены либо все действия в транзакции, либо ни одного), consistency (дающему гарантию целостности данных на всех узлах) и durability (гарантирующему сохранение данных после успешного завершения транзакции). Другими словами, чтобы гарантировать ACID, мы не можем ограничивать время выполнения транзакции и гарантировать доступность системы.

- soft-state (чтение данных может не показывать самое актуальное состояние) противоречит принципам consistency и isolation (согласно которому мы не должны видеть результаты работы других транзакций до их завершения). Возврат при чтении неактуальных значений будет потенциально приводить к нарушению целостности данных и возможности увидеть результаты другой транзакции.

- eventually consistent (записанные данные при чтении могут появляться не сразу, а с некоторой задержкой) противоречит consistency. Видимое состояние системы сразу после выполнения транзакции в BASE-системе может отличаться от того, которое оно должно иметь в конечном итоге.


## Задача 4

> Вам дали задачу написать системное решение, основой которого бы послужили:
> 
> - фиксация некоторых значений с временем жизни
> - реакция на истечение таймаута
> 
> Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
> Что это за система? Какие минусы выбора данной системы?

Описанные характеристики системы очень хорошо подпадают под возможности систем "ключ-значение", которые нашли применение в системах кэширования и хранения временных пользовательских данных (сессий). Одной из таких систем, имеющей также в своём составе требуемый по условию задачи механизм Pub/Sub, является Redis.

Будучи использованным в рамках тех задач, для которых он предназначен, Redis практически не имеет недостатков. Называть минусами Redis невозможность использовать его в качестве основного хранилища данных, и тем более в качестве аналитической системы -- я бы не стал. Это больше вопрос правильного понимания задач, для которых он создавался, и его ограничений. Имеющаяся в нём простая реализация Pub/Sub-очередей может быть при необходимости использована в работе, опять же с учётом его ограничений.