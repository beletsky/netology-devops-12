# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

> 1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
 
```
type cd
``` 
```
cd is a shell builtin
```

Есть несколько причин сделать команду `cd`  встроенной:
- хорошо, что команда доступна даже в случаях, когда в системе присутствует только командный интерпретатор;
- для её выполнения задействуется механизм просмотра файловой системы, который в любом случае должен быть встроен в командный интерпретатор для других функций (расширения имён файлов, запуска внешних команд и др.)
- она часто используется.

> 2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?

```
grep -c <some_string> <some_file>
```

> 3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

На Ubuntu 20.04 под Windows 10 WSL2:

```
ps -fp 1
```
```
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Sep03 ?        00:06:32 /init
```

> 4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
 
Сначала определим устройство ввода-вывода другой сессии терминала:

```
tty
```
```
/dev/pts/14
```

Теперь выполняем перенаправление:

```
ls 2> /dev/pts/14
```

> 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

```
grep "одновременно" < readme.md > result_05.txt && cat result_05.txt
```
```
> 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```

> 6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Для выполнения данного задания я использую эмулятор терминала `Windows Terminal`, который работает в графическом режиме по определению. Данные успешно передаются между терминалами и отображаются.

> 7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

Команда `bash 5>&1` запускает ещё один экземпляр командного интерпретатора `bash`, привязывает к нему все устройства текущего (в том числе `stdin`, `stdout`, `stderr`), и, кроме того, создаёт алиас для устройства с номером `5`, привязанный к устройству с номером `1` исходного `bash` (это `stdout`).

Внутри нового экземпляра `bash` теперь существует устройство с номером `5`:

```
ls /proc/$$/fd
```

```
0  1  2  255  5
```

Оно является синонимом `stdout`, поэтому вывод в него командой `echo netology > /proc/$$/fd/5` печатает строку `netology`. 

> 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Делаем требуемое перенаправление:

```
ls /tmp /var1 5>&2 2>&1 1>&5
```

Проверяем, что выводятся все данные, и stdout, и stderr:

```
/tmp:
ls: cannot access '/var1': No such file or directory
_MEIqRmo1e  new_path_directory
```

Проверяем, что через pipe проходит только stderr команды `ls`:

```
ls /tmp /var1 5>&2 2>&1 1>&5 | cat >/dev/null
```
```
/tmp:
_MEIqRmo1e  new_path_directory
```

> 9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Будут выведены переменные окружения, явно заданные при запуске для данной копии командного интерпретатора. В качестве разделителя строк в данном файле используются символы `\0`, поэтому переменные при выводе "сливаются" в одну строку.

Более-менее аналогичный вывод можно получить при помощи команды:

```
ps e -o args $$
```

Эта команда выведет в начало имя исполняемого файла командного интерпретатора, а переменные окружения будут разделены пробелами.

> 10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

`man proc` описывает содержимое данных файлов примерно так:
- `/proc/<PID>/cmdline` (только для чтения) содержит полную командную строку запуска данного процесса (только если это не зомби-процесс). Для зомби-процессов данный файл пуст. При попытке его чтения будет возвращено 0 байт. Аргументы командной строки перечислены в данном файле в виде набора строк, заканчивающихся символом `\0`. Конец списка аргументов обозначается дополнительным `\0` (сразу после `\0`, означающего конец последней строки).
- `/proc/<PID>/exe` является `symbolic link` (ссылку) исполняемого файла процесса. Документация описывает также разные особенности использования данной ссылки: возможность запуска копии процесса, содержимое ссылки, если исполняемый файл был уже удалён, использование её в многопоточных программах, права доступа, и т.д.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

```
cat /proc/cpuinfo | grep -woP "s?sse[\w\d_]+" | sort -u
```
```
sse2
sse4_1
sse4_2
ssse3
```

> SSE4

> 12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:
> 
>       > vagrant@netology1:~$ ssh localhost 'tty'
>       > 
>       > not a tty
> 
> Почитайте, почему так происходит, и как изменить поведение.

Команда `ssh`, будучи запущенной с указанием команды, которую необходимо выполнить, не создаёт на удалённой машине виртуальный терминал. Это позволяет более просто передавать и принимать бинарные данные (не нужно связываться с историческими особенностями работы TTY, который является, по сути, текстовым, а не бинарным, протоколом).

Тем не менее, возможность создать терминал в таких случаях есть. Для этого нужно использовать флаг -t:

```
ssh -t localhost 'tty'
```
```
/dev/pts/1
```

> 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

Запускаем долгий процесс в фоне:
```
sleep 60 &
```
```
[1] 4154
```

Проверяем принадлежность данного процесса текущей сессии:
```
ps 4154
```
```
  PID TTY      STAT   TIME COMMAND
 4154 pts/13   S      0:00 sleep 30
```

В любом другом терминале переводим этот процесс в текущий терминал:
```
repryr 4154
```

Система ждет окончания выполнения команды sleep.

В первом терминале проверяем, что процесс сменил терминал:
```
ps 4154
```
```
  PID TTY      STAT   TIME COMMAND
 4154 pts/15   Ss+    0:00 sleep 30
```
 
> 14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда tee и почему в отличие от `sudo echo` команда с `sudo tee` будет работать. 

Команда `tee` копирует содержимое stdin в stdout И в указанный файл (в оба места сразу).

В случае с первым вариантом команды, уже запущенный от имени текущего пользователя (! это важно!) попытается подсоединить stdout к указанному файлу и обнаружит, что он не имеет к нему доступа. Это произойдёт ДО попытки запуска команды `echo` с правами администратора, и поэтому данная команда не сработает.

В случае с командой `tee`, перенаправление не задействуется, вся команда успешно запускается от пользователя `root`, в процессе выполнения команда `tee` получает в качестве аргумента имя файла, и, будучи УЖЕ запущенной от имени `root`, успешно его открывает и записывает в него требуемое содержимое.
