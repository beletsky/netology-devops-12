# Домашнее задание к занятию "11.03 Микросервисы: подходы"

> Вы работаете в крупной компанию, которая строит систему на основе микросервисной архитектуры.
> Вам как DevOps специалисту необходимо выдвинуть предложение по организации инфраструктуры, для разработки и эксплуатации.

## Задача 1: Обеспечить разработку

> Предложите решение для обеспечения процесса разработки: хранение исходного кода, непрерывная интеграция и непрерывная поставка. 
> Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.
> 
> Решение должно соответствовать следующим требованиям:
> - Облачная система;
> - Система контроля версий Git;
> - Репозиторий на каждый сервис;
> - Запуск сборки по событию из системы контроля версий;
> - Запуск сборки по кнопке с указанием параметров;
> - Возможность привязать настройки к каждой сборке;
> - Возможность создания шаблонов для различных конфигураций сборок;
> - Возможность безопасного хранения секретных данных: пароли, ключи доступа;
> - Несколько конфигураций для сборки из одного репозитория;
> - Кастомные шаги при сборке;
> - Собственные докер образы для сборки проектов;
> - Возможность развернуть агентов сборки на собственных серверах;
> - Возможность параллельного запуска нескольких сборок;
> - Возможность параллельного запуска тестов;
> 
> Обоснуйте свой выбор.

С учётом первых двух условий задачи: Git и работа в облаке, выбор нужно делать из трёх основных систем: GitLab, Atlassian BitBucket или GitHub. Все три системы позволяют как работать на серверах, предоставляемых самими сервисами, так и делать развёртывание системы on-premise.

Большую часть остальных требований из условия задачи также можно реализовать на всех трёх системах (без привлечения дополнительных решений). Но, к сожалению, далеко не все, у каждой из систем имеются свои ограничения на процессы CI/CD. Например, в GitLab пока ещё нет возможности запускать ручные сборки с параметрами. Поэтому для полноценного удовлетворения всех требований одновременно необходимо будет задействовать сторонние решения. Наиболее известные/применяемые системы: Jenkins, Travis CI, TeamCity.

Как правило, системы контроля версий уже содержат в себе в том или ином виде функционал репозитория для хранения артефактов сборки (контейнеров, результатов тестов, и др.). Но поскольку этот функционал обычно реализован на некотором базово-необходимом уровне, более предпочтительным является задействовать специализированные системы хранения артефактов. Это позволит также развернуть собственное хранилище необходимых для разработки библиотек/образов/контейнеров (для уменьшения зависимости от внешних источников, быстрого доступа при сборке, гарантии неизменности артефактов, и т.д.). Фактически единственным лидером данного класса систем является Sonatype Nexus Repository Manager.

Отдельно следует рассмотреть требование "безопасного хранения секретных данных: пароли, ключи доступа". В зависимости от сложности инфраструктуры и требований к безопасности разрабатываемого решения, можно использовать три относительно приемлемых решения: 1) ручное подкладывание секретов на сервера сервисов; 2) хранение секретов в системе CI/CD и подкладывание их в результаты сборки; 3) использование централизованной системы хранения секретов. При необходимости использовать последний вариант (когда требуется централизованное управление секретами, аудит доступа к секретам, гибкая система настройки прав доступа), целесообразно остановить выбор на решении Hashicorp Vault, которое является лидером среди подобных систем.

Таким образом, предлагаемое мною решение будет состоять из трёх компонентов:

1. Система контроля версий на основе Git. В нём в отдельных репозиториях хранится исходный код всех сервисов системы, а также исходные данные для Infrastructure as a Code и Configuration as a Code.
2. Система тестирования, сборки кода и CI/CD. Отслеживает изменения в системе контроля версий, автоматически запускает сборку и тестирование новых версий сервисов, в ручном режиме производится выкладка стабильных версий сервисов в production.
3. Репозиторий артефактов, необходимых для сборки, и результатов сборки. Отсюда при разработке и сборке сервисов загружаются необходимые исходные артефакты (image, библиотеки и др.), сюда же после сборки помещаются готовые для тестирования и/или выкладки в production артефакты сборки.
4. (опционально) Система хранения секретов. Отсюда готовые сборки загружают необходимые для работы секреты.

Для системы контроля версий, п.1, я бы остановил выбор на GitLab. Основная причина такого выбора: данная система является open-source, что облегчает её изучение, доработку под свои нужны, и в какой-то степени облегчает поддержку (можно найти ответы на большинство вопросов в открытом доступе, без обращения в официальную поддержку). Хотя альтернативы до некоторой степени более функциональны в плане возможностей CI/CD и хранения артефактов и секретов, в моём решении мы замещаем этот функционал сторонними системами, поэтому эти преимущества не являются определяющими. 

Для системы тестирования, сборки и CI/CD я бы ограничил выбор системами Jenkins и TeamCity. Они практически одинаковы по функционалу. Выбор я бы обусловил прочими условиями, вплоть до личных предпочтений администраторов, которым необходимо будет работать с ними. Например, если при разработке активно используются другие продукты JetBrains, лучшим выбором будет TeamCity. Если же большинство сервисов в компании разрабатывается на Java, использование Jenkins не составит никаких проблем.

Для систем 3 и 4 мой выбор практически безальтернативен: это Sonatype Nexus Repository Manager и Hashicorp Vault.

## Задача 2: Логи

> Предложите решение для обеспечения сбора и анализа логов сервисов в микросервисной архитектуре.
> Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.
> 
> Решение должно соответствовать следующим требованиям:
> - Сбор логов в центральное хранилище со всех хостов обслуживающих систему;
> - Минимальные требования к приложениям, сбор логов из stdout;
> - Гарантированная доставка логов до центрального хранилища;
> - Обеспечение поиска и фильтрации по записям логов;
> - Обеспечение пользовательского интерфейса с возможностью предоставления доступа разработчикам для поиска по записям логов;
> - Возможность дать ссылку на сохраненный поиск по записям логов;
> 
> Обоснуйте свой выбор.

Вопрос сбора логов можно разделить на два практически непересекающихся между собой аспекта. Первый - это сбор логов о программных ошибках и отладочной информации в самих разрабатываемых сервисах. Второй - сбор логов вспомогательных систем (тех, которые НЕ разрабатываются в компании). В обоих случаях предлагаемые мною решения практически безальтернативны.

Для сбора логов со всех вспомогательных систем я предлагаю задействовать стандартное в индустрии решение на стеке ELK: LogStash/Elastic Agent/___Beats/etc для сбора логов с клиентских систем, ElasticSearch в качестве хранилища логов, Kibana для просмотра/поиска/реакции на проблемы. Альтернативные решения, например, Graylog и GrafanaLoki, обладают схожими возможностями, но менее распространены и, соответственно, менее знакомы администраторам и разработчикам.  

В разработке сервисов я предлагаю использовать систему Sentry, которая обеспечит сбор обширной информации о происходящих ошибках и их контексте. Учитывая, что при необходимости можно собранные Sentry логи "завести" в ту же систему ELK, мы получим до некоторой степени единую систему работы с логами.

## Задача 3: Мониторинг

> Предложите решение для обеспечения сбора и анализа состояния хостов и сервисов в микросервисной архитектуре.
> Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.
> 
> Решение должно соответствовать следующим требованиям:
> - Сбор метрик со всех хостов, обслуживающих систему;
> - Сбор метрик состояния ресурсов хостов: CPU, RAM, HDD, Network;
> - Сбор метрик потребляемых ресурсов для каждого сервиса: CPU, RAM, HDD, Network;
> - Сбор метрик, специфичных для каждого сервиса;
> - Пользовательский интерфейс с возможностью делать запросы и агрегировать информацию;
> - Пользовательский интерфейс с возможностью настраивать различные панели для отслеживания состояния системы;
> 
> Обоснуйте свой выбор.

Сейчас среди систем мониторинга есть два основных игрока: Zabbix и эко-система Prometeus-Grafana. Для построения новых систем, я бы рекомендовал выбирать Prometeus, поскольку Zabbix, являясь изначально более универсальной системой "всё в одном" (сбор не только метрик, но и логов и другой текстовой информации, графический интерфейс фактически сопряжён с бэкэндом для сбора и хранения данных), достаточно плохо справляется с большими объёмами данных и плохо масштабируется.

С другой стороны, Prometeus специализированной системой сбора метрик (а логи и прочая текстовая информация может быть обработана через систему логирования) и легко расширяется для сбора custom метрик при помощи написания собственных экспортеров. В некоторых конфигурациях инфраструктуры (например, когда в системе имеется большое количество динамически подключаемых и отключаемых хостов, например, некоторых оконечных устройств) Prometeus как pull-система "из коробки" не является хорошим решением, однако это легко исправляется использованием дополнительного компонента Pushgateway.

Grafana сейчас является лидирующей системой пользовательского интерфейса для просмотра метрик, и обладает широкими возможностями, с лихвой покрывающими требования задачи.