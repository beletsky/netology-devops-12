# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

> 1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток `stderr`, а не в `stdout`.

Сделаем два почти идентичных трейса, в одном из которых будет команда `cd`, а в другом нет. 
```
strace /usr/bin/bash -c "cd / ; echo" 2> strace1_1.log  
strace /usr/bin/bash -c "echo" 2> strace1_2.log
```
Напрямую сравнивать эти трейсы неудобно, поскольку в них в аргументах syscall'ов упоминаются абсолютные адреса в памяти, уникальные для каждого запуска команды. Однако для наших целей это различие несущественно, поэтому мы можем исключить адреса из трейсов: 
```
sed -i -r "s/0x[0-9a-f]{12}//g" strace1_{1,2}.log
```
После этого прямое сравнение трейсов выдаёт гораздо более приемлемый результат:
```
diff strace1_1.log strace1_2.log  
```
```
1c1
< execve("/usr/bin/bash", ["/usr/bin/bash", "-c", "cd / ; echo"],  /* 22 vars */) = 0
---
> execve("/usr/bin/bash", ["/usr/bin/bash", "-c", "echo"],  /* 22 vars */) = 0
124c124
< sysinfo({uptime=390670, loads=[2816, 4576, 5312], totalram=26783240192, freeram=11380604928, sharedram=401354752, bufferram=3193585664, totalswap=7516192768, freeswap=7516192768, procs=1149, totalhigh=0, freehigh=0, mem_unit=1}) = 0
---
> sysinfo({uptime=390171, loads=[13952, 7296, 5984], totalram=26783240192, freeram=11381710848, sharedram=401354752, bufferram=3193278464, totalswap=7516192768, freeswap=7516192768, procs=1151, totalhigh=0, freehigh=0, mem_unit=1}) = 0
149,152c149,152
< getpid()                                = 7856
< getppid()                               = 7853
< getpid()                                = 7856
< getpgrp()                               = 7853
---
> getpid()                                = 7778
> getppid()                               = 7775
> getpid()                                = 7778
> getpgrp()                               = 7775
160d159
< chdir("/")                              = 0
```
Сразу видим требуемый syscall:
> ```
> < chdir("/")                              = 0
> ```

> 2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:  
> > vagrant@netology1:\~$ file /dev/tty  
> > /dev/tty: character special (5/0)  
> > vagrant@netology1:\~$ file /dev/sda  
> > /dev/sda: block special (8/0)  
> > vagrant@netology1:\~$ file /bin/bash  
> > /bin/bash: ELF 64-bit LSB shared object, x86-64
> 
> Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

Используем `/bin/gzexe` в качестве аргумента команды `file`, так будет проще найти место доступа к файлу в выводе `strace`. Вероятнее всего, базы данных должны быть считаны утилитой `file` ДО доступа к указанному в аргументе файлу.

Беглый просмотр полного вывода `strace file /bin/gzexe 2>&1 | less` показывает, что искомые базы считываются утилитой при помощи syscall `openat`. Запустим `strace` ещё раз с фильтром `trace=/.*open.*`, чтобы увидеть все возможные открытия файлов:
```
strace -e trace=/.*open.* file /bin/gzexe
```
```
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libmagic.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/liblzma.so.5", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libbz2.so.1.0", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libz.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/share/locale/locale.alias", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/locale/C.UTF-8/LC_CTYPE", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3
openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
openat(AT_FDCWD, "/bin/gzexe", O_RDONLY|O_NONBLOCK) = 3
/bin/gzexe: POSIX shell script, ASCII text executable
+++ exited with 0 +++
```
Из дампа видим, что искомые БД ищутся утилитой в следующих местах:
> ```
> openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
> openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
> openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
> ```
Нельзя исключить вероятность того, что утилита производит поиск БД другими способами, не включающими вызов `syscall` по использованному шаблону. К счастью, в нашем случае полный дамп без фильтрации по `trace=/.*open.*` небольшой, и по нему видно, что других действий утилита не производит. 

> 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

Принцип данного трюка заключается в поддержке операционной системой `sparse files`, когда пустые участки в файле не занимают реального места на диске, а просто некоторым образом помечаются как пустые в метаданных.

Чтобы освободить место на диске, нам нужно заменить прежнее содержимое этого файла другим, коротким, например, одной из команд:
```
: > /proc/<pid>/fd/<fd>
truncate /proc/<pid>/fd/<fd>
echo | tee /proc/<pid>/fd/<fd>
```
Поскольку файл по-прежнему открыт другим процессом, ОС удалит его содержимое, освободит дисковое пространство, а прежний объём файла для открывшего его процесса будет заполнен нулями. В большинстве случаев подобная проблема возникает с файлами логов и т.п., которые только дописываются в конец файла и никогда не читаются, поэтому процесс не заметит ничего подозрительного и будет продолжать нормально работать.
 
> 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Зомби-процессы - это процессы, которые уже закончили выполнение, освободили захваченные ресурсы и оперативную память, но не были по ряду возможных причин убраны из списка процессов операционной системы. Единственный ресурс, которые они "потребляют" - это PID.

Полагаю, теоретически, если создать множество зомби-процессов, ОС может потерять возможность создавать новые процессы.

> 5. В iovisor BCC есть утилита `opensnoop`:
> > root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop  
> > /usr/sbin/opensnoop-bpfcc
> 
> На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04.

Я запускал утилиту `opensnoop` на виртуальной машине `Debian GNU/Linux 10 (buster)` под `VMWare`, поэтому список открываемых файлов не очень впечатляет:
> ```
> PID    COMM               FD ERR PATH
> 23271  vmtoolsd            9   0 /proc/meminfo
> 23271  vmtoolsd            9   0 /proc/vmstat
> 23271  vmtoolsd            9   0 /proc/stat
> 23271  vmtoolsd            9   0 /proc/zoneinfo
> 23271  vmtoolsd            9   0 /proc/uptime
> 23271  vmtoolsd            9   0 /proc/diskstats
> 1      systemd            31   0 /proc/286/cgroup
> 23271  vmtoolsd            9   0 /etc/mtab
> 23271  vmtoolsd           10   0 /proc/devices
> 23271  vmtoolsd           10   0 /proc/net/dev
> 23271  vmtoolsd           11   0 /proc/net/if_inet6
> 23271  vmtoolsd           11   0 /proc/net/if_inet6
> ```

> 6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

Дамп `strace uname -a` показывает вызовы следующих `syscall`:
```
uname({sysname="Linux", nodename="WORK", ...}) = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0xd), ...}) = 0
uname({sysname="Linux", nodename="WORK", ...}) = 0
uname({sysname="Linux", nodename="WORK", ...}) = 0
```
`man 2 uname` указывает, что:
```
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
```

> 7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
> > root@netology1:\~# test -d /tmp/some_dir; echo Hi  
> > Hi  
> > root@netology1:\~# test -d /tmp/some_dir && echo Hi  
> > root@netology1:\~#
> 
> Есть ли смысл использовать в bash `&&`, если применить `set -e`?

`;` является разделителем команд для случая, когда их нужно написать в одну строку. Команды, перечисленные через `;` выполняются друг за другом в любом случае, независимо от результата их выполнения.

`&&` является, условно говоря, операцией "логическое И". Команда, указанная второй, будет выполнена только в том случае, если указанная первой команда завершилась успешно.

В приведённом в задаче примере каталог `/tmp/some_dir` отсутствует, поэтому команда `echo Hi` не выполняется.

Хорошим, хотя и несколько искусственным, жизненным уроком, на котором можно навсегда запомнить разницу между этими разделителями, будет выполнить из корневого каталога команду вида `cd /tmp/some_dir ; rm -rf *` :-). Использование в ней `&&` решает проблему. (Хотя лучше всего, конечно, использовать вариант с прямым указанием пути `rm -rf /tmp/some_dir`.)

Использовать `&&` в ситуациях, когда необходимо обеспечить проверку правильности выполнения предыдущей команды, имеет смысл ВСЕГДА, даже когда используется настройка `set -e`, потому что данная настройка прерывает выполнение в случае ошибочного выполнения команды не безусловно: в ряде специальных случаев, например, в командах условий и циклов, в pipeline, и т.д. выполнение не прерывается.

> 8. Из каких опций состоит режим `bash set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

Данный режим хорошо использовать для отладки bash-скрипта, потому что:

- опция `-e` сразу прерывает выполнение скрипта в случае ошибок;
- опция `-u` заставляет bash выдать сообщение об ошибке в случае использования неопределённой переменной;
- опция `-x` отображает лог всех выполняемых команд с подстановкой всех переменных (в готовом для выполнения виде);
- опция `-o pipefail` приводит к использованию в качестве возвращаемого значения для всего скрипта того значения, с которым завершилась первая неудачная команда в pipeline (можно узнать причину неудачи конкретной команды, а не просто сам факт неудачи выполнения в целом).

> 9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

```
ps --no-headers -eo stat | cut -c1 | sort | uniq -c | sort -r
```
> ```
>      60 S
>       1 R
> ```
Для полноты картины, вот статусы процессов с учётом дополнительных кодов:
> ```
>      19 S
>      18 Ss
>      14 Ss+
>       4 Ssl+
>       3 S+
>       1 Sl
>       1 R+
> ```